MongoDB Injection 02

In this example, we will try to retrieve more information from the NoSQL database.

Using a bit of guess work (or previous knowledge of the application), we can deduce that there is probably a password field.

We can play around to confirm that guess:

    if we access /?search=admin'%20%26%26%20this.password.match(/.*/)%00: we can see a result.
    if we access /?search=admin'%20%26%26%20this.password.match(/zzzzz/)%00: we cannot see a result.
    if we access /?search=admin'%20%26%26%20this.passwordzz.match(/.*/)%00: we get an error message (since the field passwordzz does not exist).

Now, we have a way to perform a blind injection since we have two states:

    No result when the regular expression does not match something: false state.
    One result when the regular expression matches something: true state.

Using this knowledge, we can script the exploitation to retrieve the admin password. We will first ensure that the matching is done correctly by using: ^ and $ to make sure we do not match characters in the middle of the string (otherwise iterating will be far harder).

The algorithm looks like:

    test if password match /^a.$/ if it matches test without the wildcard `.`(to check if it's the full password). Then move to the next letter if it does not match.
    test if password match /^b.$/ if it matches test without the wildcard `.`. Then move to the next letter if it does not match.

For example, if the password is aab, the following test will be performed:

    /^a.*$/ that will return true.
    /^a$/ that will return false.
    /^aa.*$/ that will return true.
    /^aa$/ that will return false.
    /^aaa.*$/ that will return false.
    /^aab.*$/ that will return true.
    /^aab$/ that will return true. The password has been found.

With these details, you should be able to retrieve the password for the user admin. 
The password is the key to solve this exercise so it should have the following format: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX, where X can be [0-9a-f].

 * In case the password field does not exist for some records (since it's a NoSQL database), it's always a good idea to ensure its presence by using ... && this.password && this.password.match(... instead of just using ... && this.password.match(.... 

Common Mistakes:

   *  Make sure you instal httparty using the command gem install httparty if you use the Ruby script

 You can access this exercise using the following URL: http://ptc-c452fafd-db78d3e7.libcurl.so/. 
 Steps:
    1) Visit the given URL: http://ptc-c452fafd-db78d3e7.libcurl.so/. 
    2) Add parameter be: /?search=admin'%26%26this.password.match(/§§.*$/)%00:
    3) Intercept this and send to repeater also in intruder.
    4) 

    Since sending get request to /?search=admin'%26%26this.password.match(/§§.*$/)%00:

where §§ is replaced by 0-9a-z, we get several responses with length 2379.

characters a b c d e f 0 1 3 4 5 6 7 8 9 return response with length 2379.

means the password consists of the following letters given above.

now appending ^ on the regex will return true if we enter the right character.

So we send the get request as ,

/?search=admin'%26%26this.password.match(/^§§.*$/)%00:

and send it to intruder where §§ will be replaced by a b c d e f 0 1 3 4 5 6 7 8 9 and right character will give response of 2379.



    http://ptc-c452fafd-db78d3e7.libcurl.so/?search=admin%27%20%26%26%20this.password.match(/d/)%00
